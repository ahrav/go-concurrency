package main

import "sync"

// generator is a generic function that takes a done channel and a values channel as input,
// and returns a channel that streams the values from the values channel until the
// done channel is closed.
//
// Parameters:
// - done: A read-only channel of type struct{} used to signal when to stop streaming values.
// - values: A read-only channel of type T from which values are read and streamed.
//
// Returns:
// - A read-only channel of type T that streams the values from the values
// channel until the done channel is closed.
func generator[T any](done <-chan struct{}, values ...T) <-chan T {
	stream := make(chan T)
	go func() {
		defer close(stream)
		for _, v := range values {
			select {
			case <-done:
				return
			case stream <- v:
			}
		}
	}()
	return stream
}

// multiply takes a done channel, an input channel of integers, and a multiplier.
// It returns a channel that streams the multiplied values from the input channel
// until the done channel is closed.
//
// Parameters:
// - done: A read-only channel of type struct{} used to signal when to stop streaming values.
// - inStreamVals: A read-only channel of type int from which values are read and multiplied.
// - multiplier: An integer value by which each value from the input channel is multiplied.
//
// Returns:
// - A read-only channel of type int that streams the multiplied values from the input channel
// until the done channel is closed.
func multiply(done <-chan struct{}, inStreamVals <-chan int, multiplier int) <-chan int {
	multipliedValues := make(chan int)
	go func() {
		defer close(multipliedValues)
		for v := range inStreamVals {
			select {
			case <-done:
				return
			case multipliedValues <- v * multiplier:
			}
		}
	}()
	return multipliedValues
}

// add takes a done channel, an input channel of integers, and an additive.
// It returns a channel that streams the added values from the input channel
// until the done channel is closed.
//
// Parameters:
// - done: A read-only channel of type struct{} used to signal when to stop streaming values.
// - inStreamVals: A read-only channel of type int from which values are read and added.
// - additive: An integer value that is added to each value from the input channel.
//
// Returns:
// - A read-only channel of type int that streams the added values from the input channel
// until the done channel is closed.
func add(done <-chan struct{}, inStreamVals <-chan int, additive int) <-chan int {
	addedValues := make(chan int)
	go func() {
		defer close(addedValues)
		for v := range inStreamVals {
			select {
			case <-done:
				return
			case addedValues <- v + additive:
			}
		}
	}()
	return addedValues
}

// repeat takes a done channel and a variadic list of values.
// It returns a channel that streams the values repeatedly until the done channel is closed.
//
// Parameters:
// - done: A read-only channel of type struct{} used to signal when to stop streaming values.
// - values: A variadic list of values of type T to be streamed repeatedly.
//
// Returns:
// - A read-only channel of type T that streams the values repeatedly until the done channel is closed.
func repeat[T any](done <-chan struct{}, values ...T) <-chan T {
	valueStream := make(chan T)
	go func() {
		defer close(valueStream)
		for {
			for _, v := range values {
				select {
				case <-done:
					return
				case valueStream <- v:
				}
			}
		}
	}()
	return valueStream
}

// repeatFn takes a done channel and a function that returns a value of any type.
// It returns a channel that streams the values generated by the function until the done channel is closed.
//
// Parameters:
// - done: A read-only channel of type struct{} used to signal when to stop streaming values.
// - fn: A function that returns a value of any type to be streamed.
//
// Returns:
// - A read-only channel of type any that streams the values generated by the function until the done channel is closed.
func repeatFn(done <-chan struct{}, fn func() any) <-chan any {
	valueStream := make(chan any)
	go func() {
		defer close(valueStream)
		defer func() {
			if r := recover(); r != nil {
				// Handle panic here...
			}
		}()
		for {
			select {
			case <-done:
				return
			case valueStream <- fn():
			}
		}
	}()
	return valueStream
}

// take takes a done channel, a value stream channel, and a number of values to take.
// It returns a channel that streams the specified number of values from the value stream
// until the done channel is closed.
//
// Parameters:
// - done: A read-only channel of type struct{} used to signal when to stop streaming values.
// - valueStream: A read-only channel of type T from which values are read.
// - num: An integer specifying the number of values to take from the value stream.
//
// Returns:
// - A read-only channel of type T that streams the specified number of values from the value stream
// until the done channel is closed.
func take[T any](done <-chan struct{}, valueStream <-chan T, num int) <-chan T {
	takeStream := make(chan T)
	go func() {
		defer close(takeStream)
		for i := 0; i < num; i++ {
			select {
			case <-done:
				return
			// Check if the valueStream is closed before reading from it to avoid a panic.
			// This prevents reading zero values when the valueStream is closed and empty.
			case v, ok := <-valueStream:
				if !ok {
					return
				}
				takeStream <- v
			}
		}
	}()
	return takeStream
}

// toInt converts a stream of values of any type to a stream of integers.
// It reads values from the input channel, converts them to integers, and streams them
// until the done channel is closed.
//
// Parameters:
// - done: A read-only channel of type struct{} used to signal when to stop streaming values.
// - valueStream: A read-only channel of type any from which values are read and converted to integers.
//
// Returns:
// - A read-only channel of type int that streams the converted integer values until the done channel is closed.
func toInt(done <-chan struct{}, valueStream <-chan any) <-chan int {
	intStream := make(chan int)
	go func() {
		defer close(intStream)
		for v := range valueStream {
			select {
			case <-done:
				return
			case intStream <- v.(int):
			}
		}
	}()
	return intStream
}

// primeFinder filters a stream of integers, returning only the prime numbers.
// It reads values from the input channel, checks if they are prime, and streams the prime numbers
// until the done channel is closed.
//
// Parameters:
// - done: A read-only channel of type struct{} used to signal when to stop streaming values.
// - valueStream: A read-only channel of type int from which values are read and checked for primality.
//
// Returns:
// - A read-only channel of type any that streams the prime numbers until the done channel is closed.
// NOTE: This is NOT a pattern, this is just a helper function.
func primeFinder(done <-chan struct{}, valueStream <-chan int) <-chan any {
	isPrime := func(value int) bool {
		for i := 2; i < value; i++ {
			if value%i == 0 {
				return false
			}
		}
		return value > 1
	}

	primeStream := make(chan any)
	go func() {
		defer close(primeStream)
		for v := range valueStream {
			if isPrime(v) {
				select {
				case <-done:
					return
				case primeStream <- v:
				}
			}
		}
	}()
	return primeStream
}

// fanIn multiplexes multiple input channels into a single output channel.
// It reads values from the input channels and streams them into a single output channel
// until the done channel is closed.
//
// Parameters:
// - done: A read-only channel of type struct{} used to signal when to stop streaming values.
// - channels: A variadic list of read-only channels of type T from which values are read and multiplexed.
//
// Returns:
// - A read-only channel of type T that streams the multiplexed values from the input channels until the done channel is closed.
func fanIn[T any](done <-chan struct{}, channels ...<-chan T) <-chan T {
	var wg sync.WaitGroup
	multiplexedStream := make(chan T)
	multiplex := func(c <-chan T) {
		defer wg.Done()
		for i := range c {
			select {
			case <-done:
				return
			case multiplexedStream <- i:
			}
		}
	}

	wg.Add(len(channels))
	for _, c := range channels {
		go multiplex(c)
	}

	go func() {
		wg.Wait()
		close(multiplexedStream)
	}()

	return multiplexedStream
}
